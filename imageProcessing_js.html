<!DOCTYPE html>
<html>
    <head>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;900&display=swap');
            body{
                width : max-content;
                margin: auto;
            }
            h2{
                margin-bottom: 30px;
                font-family: 'Noto Sans KR', sans-serif;
                text-align: center;
            }
            h5{
                margin-bottom : 10px;
                font-weight: normal;
            }
            .input-file-btn {
                padding : 10px 13px; background-color : #ffb74d;
                border-radius: 30px; color:white; cursor: pointer;
                font-family: 'Noto Sans KR', sans-serif; text-align: center;
                font-size: 12pt; font-weight : normal;
                margin-right : 1em;
            }

            select {
                height: 44px;
                background-size: 30px;
                outline: 0 none;
                font-family: inherit;
                font-size: 13px;
                line-height: 1.5;

                color: #444;
                background-color: #fff;

                padding: 0.6em 0.8em;
                margin-left: 1em;
                
                border-top: none;
                border-left: none;
                border-right:  none;
                border-bottom: 1px solid #aaa;
            }


        </style>
        <script lang="javascript">
        // 전역변수 선언
        var inCanvas, inCtx, inPaper, inFile;
        var inImage, inH, inW;  //중요
        var outCanvas, outCtx, outPaper, outFile;
        var outImage, outH, outW;

        // 함수 선언부
        function init(){
            inCanvas = document.getElementById('inCanvas');
            inCtx = inCanvas.getContext('2d');
            outCanvas = document.getElementById('outCanvas');
            outCtx = outCanvas.getContext('2d');
        }

        function openImage(){
            inFile = document.getElementById('inFile').files[0];
            
            // 이미지 폭과 높이 계산
            inH = inW = Math.floor(Math.sqrt(inFile.size));

            // 이미지 크기의 2차원 메모리를 할당
            inImage = new Array(inH);
            for(i=0; i<inH; i++)    inImage[i] = new Array(inW);

            // 캔버스 크기 지정
            inCanvas.height = inH;
            inCanvas.width = inW;

            // 이미지 파일을 배열로 전환
            var reader = new FileReader();      // 파일 객체
            reader.readAsBinaryString(inFile);
            reader.onload = function(){
                var blob = reader.result;   //파일을 한 덩어리(blob)으로 가져옴

                //blob에서 한 점 한 점을 2차원 배열에 넣기
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        var sPixel = (i * inH + j); //시작 위치
                        var ePixel = (i * inH + j) + 1; //끝 위치
                        inImage[i][j] = blob.slice(sPixel, ePixel).charCodeAt(0);   //'꽭'을 숫자로 변경
                    }
                }                
                displayImage();
            }
        }

        function displayImage(){
            inPaper = inCtx.createImageData(inH, inW);
            // 입력 메모리를 종이에 찍기
            for(i=0; i<inH; i++){
                for(j=0; j<inW; j++){
                    var px = inImage[i][j];   
                    // grayscale 이미지; R, G, B 값 동일
                    inPaper.data[(i * inH + j) * 4 + 0] = px;   //R
                    inPaper.data[(i * inH + j) * 4 + 1] = px;   //G
                    inPaper.data[(i * inH + j) * 4 + 2] = px;   //B
                    inPaper.data[(i * inH + j) * 4 + 3] = 255;   //Alpha(opacity)
                }
            }
            inCtx.putImageData(inPaper, 0, 0); //종이를 캔버스(0, 0)에 붙이기   

            outPaper = outCtx.createImageData(outH, outW);
            // 출력 메모리를 종이에 찍기
            for(i=0; i<outH; i++){
                for(j=0; j<outW; j++){
                    var px = outImage[i][j];
                    // grayscale 이미지; R, G, B 값 동일
                    outPaper.data[(i * outH + j) * 4 + 0] = px;   //R
                    outPaper.data[(i * outH + j) * 4 + 1] = px;   //G
                    outPaper.data[(i * outH + j) * 4 + 2] = px;   //B
                    outPaper.data[(i * outH + j) * 4 + 3] = 255;   //Alpha(opacity)
                }
            }
            outCtx.putImageData(outPaper, 0, 0); //종이를 캔버스(0, 0)에 붙이기 
        }

            // 영상 처리 알고리즘 함수부
            function selectAlgo(selNum) {
                switch (parseInt(selNum.value)) {
                    case 100 :  equal_image(); break;   // 동일 영상
                    case 101 :  add_image(); break;     //밝게
                    case 102 :  subtract_image(); break;    //어둡게
                    case 103 :  reverse_image(); break; //반전
                    case 104 :  bw_image(); break;      //흑백
                    case 105 :  bwMean_image(); break;  //흑백(평균기준)
                    case 106 :  bwMedian_image(); break; //흑백(중앙값기준)
                    case 107 :  gamma_image(); break;   //감마
                    case 108 :  emphasize_image(); break; //범위강조
                    case 109 :  paraCap_image(); break; //파라볼라(캡)
                    case 110 :  paraCup_image(); break; //파라볼라(컵)
                    case 111 :  spNoise_image(); break; //소금-후추 노이즈

                    case 201 :  mirror1_image(); break; //좌우미러링
                    case 202 :  mirror2_image(); break; //상하미러링
                    case 203 :  zoomOut_image(); break; //줌아웃
                    case 204 :  zoomInF_image(); break; //줌인(forwarding)
                    case 205 :  zoomInB_image(); break; //줌아웃(backwarding)
                    case 206 :  move_image(); break;    //이동(x, y 입력)
                    case 207 :  rotate_image(); break;  //회전(각도 입력)

                    case 301 : histoSt_image(); break;   //히스토그램 스트레칭
                    case 302 : endIn_image(); break;    //엔드인 탐색
                    case 303 : histoEqual_image(); break;   //히스토그램 평활화

                    case 401 : blurr_image(); break;    //블러
                    case 402 : gaussian_image(); break; //가우시안 필터
                    case 403 : mosaic_image(); break;     //모자이크        
                    case 404 : embos_image(); break;    //엠보싱
                    case 405 : edge_image(); break;     //경계선 검출
                    case 406 : laplace_image(); break;  //라플라시안 필터
                    case 407 : sharpen_image(); break;  //샤프닝
                }
            }

            function equal_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[i][j] = inImage[i][j];
                    }
                }
                displayImage();
            }

            function add_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                var value = parseInt(prompt("밝게하기", 20));
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(outImage[i][j] + value >255) outImage[i][j] = 255;
                        else    outImage[i][j] = inImage[i][j] + value;
                    }
                }
                displayImage();
            }

            function subtract_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                var value = parseInt(prompt("어둡게하기", 20));
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(outImage[i][j] - value < 0) outImage[i][j] = 0;
                        else    outImage[i][j] = inImage[i][j] - value;
                    }
                }
                displayImage();
            }

            function reverse_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[i][j] = 255 - inImage[i][j];
                    }
                }
                displayImage();
            }

            function bw_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                var value = 128;    //흑백 나누는 기준
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(inImage[i][j] < value) outImage[i][j] = 0;
                        else    outImage[i][j] = 255;
                    }
                }
                displayImage();
            }

            function bwMean_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
                
                var sum = 0;
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        sum += (inImage[i][j]);
                    }
                }
                var value = sum / (inH * inW);    //흑백 나누는 기준
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(inImage[i][j] < value) outImage[i][j] = 0;
                        else    outImage[i][j] = 255;
                    }
                }
                displayImage();
            }

            function bwMedian_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(inH);
                for(i=0; i<inH; i++)    outImage[i] = new Array(inW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
                
                var tmparray = [];
                var value;    //흑백 나누는 기준
                
                //inImage의 값을 일차원 배열에 저장
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tmparray.push(inImage[i][j]);
                    }
                }
                
                //median 구하기
                var index = inH * inW /2;
                if(index == parseInt(index)) value = (tmparray.sort()[index-1]+tmparray.sort()[index])/2;
                else value = tmparray.sort()[parseInt(index)];
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(inImage[i][j] < value) outImage[i][j] = 0;
                        else    outImage[i][j] = 255;
                    }
                }
                displayImage();
            }

            function gamma_image(){
                var gamma = prompt("gamma", 1.5);
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tmp = Math.pow(inImage[i][j]/255, gamma) * 255;
                        outImage[i][j] = tmp ;
                    }
                }
                displayImage();
            }

            function emphasize_image(){
                var start = parseInt(prompt("시작", 50));
                var end = parseInt(prompt("끝", 100));
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        if(inImage[i][j] <= start && inImage[i][j] <= end) outImage[i][j] = 255;
                        else outImage[i][j] = inImage[i][j] ;
                    }
                }
                displayImage();
            }

            function paraCap_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tmp = Math.pow(inImage[i][j]/127 - 1, 2) * 255;
                        outImage[i][j] = tmp ;
                    }
                }
                displayImage();
            }

            function paraCup_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tmp = -255 * Math.pow(inImage[i][j]/127 -1 , 2) + 255;
                        outImage[i][j] = tmp ;
                    }
                }
                displayImage();
            }

            function spNoise_image(){
                var amount = parseInt(prompt("노이즈 양", 10));
                var noise = parseInt(outH * outW * amount / 100);
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[i][j] = inImage[i][j];
                    }
                }

                for(i=0; i<noise; i++){
                    if(i%2 == 0)
                    outImage[parseInt(Math.random()*256)][parseInt(Math.random()*256)]
                        = 0;
                    else
                        outImage[parseInt(Math.random()*256)][parseInt(Math.random()*256)]
                        = 255;
                }
                displayImage();
            }

            function mirror1_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[i][inW -1 - j] = inImage[i][j];
                    }
                }
                displayImage();
            }

            function mirror2_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                        outImage[inH -1 - i]= inImage[i];
                }
                displayImage();
            }

            function zoomOut_image(){
                var scale = parseInt(prompt("축소배율", 2));
                //출력 영상의 크기를 계산
                outH = parseInt(inH/scale); outW = parseInt(inW/scale);
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[parseInt(i/scale)][parseInt(j/scale)] = inImage[i][j]; //덮어씌움 => 평균으로 하나 덮어씌우나 생각보다 차이 안남
                    }
                }
                displayImage();
            }

            function zoomInF_image(){
                var scale = parseInt(prompt("확대배율", 2));
                //출력 영상의 크기를 계산
                outH = parseInt(inH*scale); outW = parseInt(inW*scale);
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[parseInt(i*scale)][parseInt(j*scale)] = inImage[i][j];
                    }
                }
                displayImage();
            } 

            function zoomInB_image(){
                var scale = parseInt(prompt("확대배율", 2));
                //출력 영상의 크기를 계산
                outH = parseInt(inH*scale); outW = parseInt(inW*scale);
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        outImage[i][j] = inImage[parseInt(i/scale)][parseInt(j/scale)];
                    }
                }
                displayImage();
            } 

            function move_image(){
                var dx = parseInt(prompt("가로 이동", 10));
                var dy = parseInt(prompt("세로 이동", 10));
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                var targetX; var targetY
                // 영상처리 알고리즘
                for(i=0; i<outH; i++){
                    targetY = i - dy;
                    for(j=0; j<outW; j++){
                        targetX = j - dx;
                        if(targetX <= 255 && targetX >= 0 && targetY <= 255 && targetY >= 0)
                            outImage[i][j] = inImage[targetY][targetX];
                        //else    outImage[i][j] = 255;
                    }
                }
                displayImage();
            } 

            function rotate_image(){
                var scale = prompt("회전 각", 30);
                var rad = Math.PI / 180 * scale;
                var cenX = inH / 2; var cenY = inW / 2;

                //출력 영상의 크기를 계산
                outH = inH; outW =inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        var oldX = parseInt((j-cenX) * Math.cos(rad) + (i-cenY) * Math.sin(rad) + cenX);
                        var oldY = parseInt((i-cenY) * Math.cos(rad) - (j-cenX) * Math.sin(rad) + cenY);
                        if(oldX >= 0 && oldX < outW && oldY >= 0 && oldY < outH )
                            outImage[i][j] = inImage[oldY][oldX];
                    }
                }
                displayImage();
            } 

            function histoSt_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                // new = (old-low) / (high - low) * 255
                var low = inImage[0][0]; var high = inImage[0][0];

                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        if(inImage[i][j] < low) low = inImage[i][j];
                        if(inImage[i][j] > high) high = inImage[i][j];
                    }
                }

                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        outImage[i][j] = (inImage[i][j] - low) / (high - low) * 255;
                    }
                }

                displayImage();
            }

            function endIn_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                // new = (old-low) / (high - low) * 255
                var low = inImage[0][0]; var high = inImage[0][0];

                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        if(inImage[i][j] < low) low = inImage[i][j];
                        if(inImage[i][j] > high) high = inImage[i][j];
                    }
                }

                low += 50; high -= 50;

                for(i=0; i<outH; i++){
                    for(j=0; j<outW; j++){
                        outImage[i][j] = (inImage[i][j] - low) / (high - low) * 255;
                    }
                }

                displayImage();
            }

            function histoEqual_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                // 1단계. 히스토그램 생성
                var histo = new Array(256); // 픽셀값 범위 0~255
                for(i=0; i<256; i++) histo[i] = 0;
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        histo[inImage[i][j]] ++;
                    }
                }

                // 2단계. 누적 히스토그램 생성
                var culHisto = new Array(256); // 픽셀값 범위 0~255
                for(i=0; i<256; i++) culHisto[i] = 0;
                var sumValue = 0;
                for(i=0; i<256; i++){
                    sumValue += histo[i];
                    culHisto[i] = sumValue;
                } 

                // 3단계. 누적합 정규화
                // normal[i] = culHisto[i] * (1 / (inH*inW)) * 255
                var norHisto = new Array(256);
                for(i=0; i<256; i++) norHisto[i] = 0.0;
                for(i=0; i<256; i++) norHisto[i] = culHisto[i] * (1.0 / (inH * inW)) * 255.0;

                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        outImage[i][j] = parseInt(norHisto[inImage[i][j]]);
                    }
                }
                displayImage();
            }

            function embos_image(){
                    //출력 영상의 크기를 계산
                    outH = inH; outW = inW;
                    
                    // 이미지 크기의 2차원 메모리를 할당
                    outImage = new Array(outH);
                    for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                    // 캔버스 크기 지정
                    outCanvas.height = outH;
                    outCanvas.width = outW;

                    // 영상처리 알고리즘
                    // 마스크
                    var mask = [[-1.0, 0.0, 0.0],
                                [0.0, 0.0, 0.0],
                                [0.0, 0.0, 1.0]];
                    
                    // 임시입력배열 생성 및 초기화
                    var tempArr = new Array(inH+2);
                    for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
                    for(i=0; i<inH+2; i++){
                        for(j=0; j<inW+2; j++){
                            tempArr[i][j] = 127.0;
                        }
                    }

                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                        }
                    }

                    // 임시 출력배열(출력 배열 크기 동일)
                    var tmpOutput = new Array(outH);
                    for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

                    // 회선연산
                    // 마스크 적용
                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            //한 점에 대해 처리
                            var S = 0.0;
                            for(m=0; m<3; m++){
                                for(n=0; n<3; n++){
                                    S += tempArr[i+m][j+n] * mask[m][n];
                                }
                              }
                            tmpOutput[i][j] = S + 127.0;
                            /* 127 더하는 이유 : 가중치 합이 0이므로 원래의 영상보다 어두워지기 때문에 보정 */
                        }
                    }
                    

                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            outImage[i][j] = parseInt(tmpOutput[i][j]);
                        }
                    }
                    displayImage();
                }

            function blurr_image(){
            //출력 영상의 크기를 계산
            outH = inH; outW = inW;
                
            // 이미지 크기의 2차원 메모리를 할당
            outImage = new Array(outH);
            for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            // 영상처리 알고리즘
            // 마스크
            var mask = [[1/9, 1/9, 1/9],
                        [1/9, 1/9, 1/9],
                        [1/9, 1/9, 1/9]];
                
            // 임시입력배열 생성 및 초기화
            var tempArr = new Array(inH+2);
            for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
            for(i=0; i<inH+2; i++){
                for(j=0; j<inW+2; j++){
                    tempArr[i][j] = 127.0;
                }
            }

            for(i=0; i<inH; i++){
                for(j=0; j<inW; j++){
                    tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                }
            }

            // 임시 출력배열(출력 배열 크기 동일)
            var tmpOutput = new Array(outH);
            for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

            // 회선연산
            // 마스크 적용
            for(i=0; i<inH; i++){
                for(j=0; j<inW; j++){
                    //한 점에 대해 처리
                    var S = 0.0;
                    for(m=0; m<3; m++){
                        for(n=0; n<3; n++){
                            S += tempArr[i+m][j+n] * mask[m][n];
                        }
                      }
                        outImage[i][j] = parseInt(S);
                }
            }

            displayImage();
        }
                    
            function edge_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                // 마스크
                var mask = [[0, -1, 0],
                            [-1, 2, 0],
                            [0, 0, 0]];
                    
                // 임시입력배열 생성 및 초기화
                var tempArr = new Array(inH+2);
                for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
                for(i=0; i<inH+2; i++){
                    for(j=0; j<inW+2; j++){
                        tempArr[i][j] = 127.0;
                    }
                }

                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                    }
                }

                // 임시 출력배열(출력 배열 크기 동일)
                var tmpOutput = new Array(outH);
                for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

                // 회선연산
                // 마스크 적용
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        //한 점에 대해 처리
                        var S = 0.0;
                        for(m=0; m<3; m++){
                            for(n=0; n<3; n++){
                                S += tempArr[i+m][j+n] * mask[m][n];
                            }
                          }
                            outImage[i][j] = parseInt(S);
                    }
                }
                displayImage();
            }

            function mosaic_image(){
                var scale = Math.pow(2,parseInt(prompt("모자이크 크기", 2)));
                if (scale>inH) scale = inH;
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
    
                // 영상처리 알고리즘
                for(i=0; i<inH-scale+1; i+=scale){
                    for(j=0; j<inW-scale+1; j+=scale){
                        var mean = 0.0;
                        for(m=0; m<scale; m++){
                            for(n=0; n<scale; n++) {
                                mean += inImage[i+m][j+n]/Math.pow(scale,2);
                        }
                    }
                        for(m=0; m<scale; m++){
                            for(n=0; n<scale; n++)  outImage[i+m][j+n] = mean;
                        }
                    }
                }
                displayImage();
            }

            function gaussian_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;

                // 영상처리 알고리즘
                // 마스크
                var mask = [[1/16, 1/8, 1/16],
                            [1/8, 1/4, 1/8],
                            [1/16, 1/8, 1/16]];
                    
                // 임시입력배열 생성 및 초기화
                var tempArr = new Array(inH+2);
                for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
                for(i=0; i<inH+2; i++){
                    for(j=0; j<inW+2; j++){
                        tempArr[i][j] = 127.0;
                    }
                }

                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                    }
                }

                // 임시 출력배열(출력 배열 크기 동일)
                var tmpOutput = new Array(outH);
                for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

                // 회선연산
                // 마스크 적용
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        //한 점에 대해 처리
                        var S = 0.0;
                        for(m=0; m<3; m++){
                            for(n=0; n<3; n++){
                                S += tempArr[i+m][j+n] * mask[m][n];
                            }
                          }
                            outImage[i][j] = parseInt(S);
                    }
                }
                displayImage();
            }

            function laplace_image(){
                    //출력 영상의 크기를 계산
                    outH = inH; outW = inW;
                    
                    // 이미지 크기의 2차원 메모리를 할당
                    outImage = new Array(outH);
                    for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                    // 캔버스 크기 지정
                    outCanvas.height = outH;
                    outCanvas.width = outW;

                    // 영상처리 알고리즘
                    // 마스크
                    var mask = [[0, 1, 0],
                                [1, -4, 1],
                                [0, 1, 0]];
                    
                    // 임시입력배열 생성 및 초기화
                    var tempArr = new Array(inH+2);
                    for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
                    for(i=0; i<inH+2; i++){
                        for(j=0; j<inW+2; j++){
                            tempArr[i][j] = 127.0;
                        }
                    }

                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                        }
                    }

                    // 임시 출력배열(출력 배열 크기 동일)
                    var tmpOutput = new Array(outH);
                    for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

                    // 회선연산
                    // 마스크 적용
                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            //한 점에 대해 처리
                            var S = 0.0;
                            for(m=0; m<3; m++){
                                for(n=0; n<3; n++){
                                    S += tempArr[i+m][j+n] * mask[m][n];
                                }
                              }
                            tmpOutput[i][j] = S + 127.0;
                            /* 127 더하는 이유 : 가중치 합이 0이므로 원래의 영상보다 어두워지기 때문에 보정 */
                        }
                    }
                    

                    for(i=0; i<inH; i++){
                        for(j=0; j<inW; j++){
                            outImage[i][j] = parseInt(tmpOutput[i][j]);
                        }
                    }
                    displayImage();
                }
            
            function sharpen_image(){
                //출력 영상의 크기를 계산
                outH = inH; outW = inW;
                
                // 이미지 크기의 2차원 메모리를 할당
                outImage = new Array(outH);
                for(i=0; i<outH; i++)    outImage[i] = new Array(outW);

                // 캔버스 크기 지정
                outCanvas.height = outH;
                outCanvas.width = outW;
                
                // 영상처리 알고리즘
                // 마스크
                var mask = [[-1, -1, -1],
                            [-1, 9, -1],
                            [-1, -1, -1]];
                    
                // 임시입력배열 생성 및 초기화
                var tempArr = new Array(inH+2);
                for(i=0; i<inH+2; i++)    tempArr[i] = new Array(inW+2);
                for(i=0; i<inH+2; i++){
                    for(j=0; j<inW+2; j++){
                        tempArr[i][j] = 127.0;
                    }
                }

                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        tempArr[i+1][j+1] = parseFloat(inImage[i][j]);
                    }
                }

                // 임시 출력배열(출력 배열 크기 동일)
                var tmpOutput = new Array(outH);
                for(i=0; i<outH; i++)    tmpOutput[i] = new Array(outW);

                // 회선연산
                // 마스크 적용
                for(i=0; i<inH; i++){
                    for(j=0; j<inW; j++){
                        //한 점에 대해 처리
                        var S = 0.0;
                        for(m=0; m<3; m++){
                            for(n=0; n<3; n++){
                                S += tempArr[i+m][j+n] * mask[m][n];
                            }
                          }
                            outImage[i][j] = parseInt(S);
                    }
                }
                displayImage();
            }
            
        </script>
    </head>
    <body onload="init()">
        <div style="margin-top: 70px;">
            <h2>영상 처리 프로그램</h2>
            <div style="display: flex;">
                <div style="width: fit-content; margin-right: 20px;">
                    <h5>원본</h5>
                     <canvas id="inCanvas" style = "background-color: antiquewhite;"></canvas>
                </div>
                <div style="width: fit-content;">
                    <h5>변환 후</h5>
                    <canvas id="outCanvas" style = "background-color: rgb(215, 242, 250);"></canvas>
                </div>
            </div>
        </div>
            <form style="margin-top: 25px;">
            <label class="input-file-btn" for="inFile">파일 업로드</label>
            <input type="file" id="inFile" style="display:none" onchange="openImage()" />
            <select name="menu" onchange="selectAlgo(this.form.menu)">
                <option value=0> 기능 선택 </option>
                <optgroup label="화소점 처리">
                    <option value=100>동일영상</option>
                    <option value=101>밝게하기</option>
                    <option value=102>어둡게하기</option>
                    <option value=103>반전하기</option>
                    <option value=104>흑백(128기준)</option>
                    <option value=105>흑백(평균기준)</option>
                    <option value=106>흑백(중앙값기준)</option>
                    <option value=107>감마 보정</option>
                    <option value=108>범위강조</option>
                    <option value=109>파라볼라(캡)</option>
                    <option value=110>파라볼라(컵)</option>
                    <option value=111>소금-후추 노이즈</option>
                </optgroup>
                <optgroup label="기하학 처리">
                    <option value=201>좌우 미러링</option>
                    <option value=202>상하 미러링</option>
                    <option value=203>축소</option>
                    <option value=204>확대(forwarding)</option>
                    <option value=205>확대(backwarding)</option>
                    <option value=206>이동</option>
                    <option value=207>회전</option>
                </optgroup>
                <optgroup label="히스토그램 처리">
                    <option value=301>히스토그램 스트레칭</option>
                    <option value=302>엔드인 탐색</option>
                    <option value=303>평활화</option>
                </optgroup>
                <optgroup label="화소영역 처리">
                    <option value=401>블러링</option>
                    <option value=402>가우시안</option>
                    <option value=403>모자이크</option>
                    <option value=404>엠보싱</option>
                    <option value=405>경계선</option>
                    <option value=406>라플라시안</option>
                    <option value=407>샤프닝</option>
                </optgroup>
            </select>
            </form>
        </div>
    </body>
</html>